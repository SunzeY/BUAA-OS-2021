# 页面置换竞争性实验报告

## 1. 概述

这次实验期间由于自己有两门专业课的大作业，因而并没有花很多时间来设计自己的页面置换算法。所以实际上在第一天实现了一个循环链表维护的“第二次机会算法”就逃了~，最后的名次也只是在被选入申优的边缘。所以现在也只能水一水报告了。



## 2.算法设计思想

算法本身就是第二次机会算法。



## 3.算法实现技巧

最后自己提交的代码如下：

```c++
#pragma GCC optimize (2)
#include "pageReplace.h"
#define MAX_PHY_PAGE 64
#define MAX_PAGE 12
#define true 1
#define false 0
#define GET_PAGE(x) ((x)>>MAX_PAGE)

char lastuse[MAX_PHY_PAGE];

void pageReplace(long* physic_memory, long nwAdd)
{
    static int point  = 0;
    static int cur_filled_num = 0;
    int page_num = GET_PAGE(nwAdd);
    for (register int i = 0; i <MAX_PHY_PAGE; i++){
        if (page_num==physic_memory[i]) {
            lastuse[i]=true;
            return;
        }
    }
    if (cur_filled_num<MAX_PHY_PAGE) {
        physic_memory[cur_filled_num++] = page_num;
    }

    else {
        while(lastuse[point]) {
            lastuse[point]=false;
            point = (point+1) & (MAX_PHY_PAGE-1);
        }
        physic_memory[point] = page_num;
        point = (point+1) & (MAX_PHY_PAGE-1);
    }
}
```

唯一的一点点实现的技巧是在一开始装填时直接用一个指针依次往后填，不需要遍历整个TLB。此后再使用一个point指针作为算法的主指针。



## 4. 以及竞争实验过程中的优化与改进

当然在竞争实验的过程中尝试过一些别的优化，但都因为实际效果不理想而弃用了，具体如下：

#### 1.空间压缩

既然保存节点是否被二次使用过实际只有1位，所以可以用如下方法节省空间

```C
map[page_num/32]&(1<<(page_num%32)...
```

但是由于自己占的内存已经是分档中最小的了， 实际上多了一次位运算，遂弃用。



#### 2.hashMap保存是否保有这个页面，从而不需要遍历查找：

在实现中一开始每个页面的页号到对应TLB中index的转化表，需要`页面页号*sizeof(int)` 的大空间：

```
int Page2index[1<<29-1];
```

结果是这个空间耗费极大， 遂弃用， 个人感觉真正的hashmap(如开更少的空间并设置更加局部化的散列函数)可能会有比较好的效果...)



#### 3. 借用局部性原则更改搜索的方法

在时钟算法中，point指针始终指向上一次使用的页面，因此，根据页表查询的局部性原理，其附近的页面更有可能被再次使用，因此使用如下的以last_point为基址上下遍历这个链表的方法。具体如图所示:

```
	for (register int i = 0; i <=MAX_PHY_PAGE_HALF; i++){
        temp_point = (i+last_point)&(MAX_PHY_PAGE-1);
        if (page_num==physic_memory[temp_point]) {
            lastuse[temp_point]=true;
            last_point = temp_point;
            return;
        }
        temp_point = (last_point-i<0? last_point-i+MAX_PHY_PAGE : last_point-i)&(MAX_PHY_PAGE-1);
        if (page_num==physic_memory[temp_point]) {
            lastuse[temp_point]=true;
            last_point = temp_point;
            return;
        }
    }

```

最后的结果是这个方法在使用perf的评价方法中取得较好的成绩，但直接看运行时间的评价方法反而拉慢。由于最后以为还是以时间最为评价标准，所以最后没有提交这一版本。



## 5.本地测试情况

只使用了官方的测试和官方给出的生产模拟矩阵乘法过程中发生的页面查找的测试数据。

